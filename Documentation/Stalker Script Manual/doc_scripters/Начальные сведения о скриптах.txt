Начальные сведения о скриптах

ПРЕДИСЛОВИЕ
Lamp.gif 	Для чего нужны скрипты и сведения и их использовании - Rez@niy aka Oxygenium
В скриптах содержаться инструкции для выполнения по условиям.


Итак, начнём. Создадим в папке gamedata/scripts файл с любым названием и расширением .script. Пускай, my_test.script. В нем будем прописывать функции.
Рассмотрим простой скрипт спавна предмета в рюкзак ГГ. Пропишем:

--*********************************************
--**TESTING**
--*********************************************
--
-- Создает в рюкзаке ГГ "калаш"
function ak_create()
    alife():create("wpn_ak74", db.actor:position(), db.actor:level_vertex_id(), db.actor:game_vertex_id(), db.actor:id())
end

Давайте разбирать.
Игра считывает весь код из файла, поэтому не удивляйтесь, если игра вылетит при наличии лишнего текста, символов и прочего ненужного в скрипте. Однако, подобных проблем возникать не будет, если мы закомментируем лишнее. Чтобы игра не считывала текст, перед ним мы ставим две черточки, два минуса, два дефиса, в общем называйте как угодно:

--

Часто таким образом оставляют словесную подсказку того, что делает данный участок кода, либо комментируют код, который на данный момент не нужен, но возможно пригодится в дальнейшем. В общем, зачастую комментарий - это пояснения к исходному тексту программы. В данном случае, система не будет считывать следующие строки:

--*********************************************
--**TESTING**
--*********************************************
--
-- Создает в рюкзаке ГГ "калаш"

Многострочный комментарий выглядит так

--[[ком
мен
та
рий]]

Идем дальше. function - всегда обязательное начало, это что-то в роде id в языке LUA. После function отступаем и пишем текст. Данный текст может состоять из букв латинского алфавита и цифр, при этом важно, чтобы этот текст начинался с буквы и в нём не содержалось пробелов. Этот текст будет названием функции. Не забываем после названия функции дописать две круглые скобки:

()

Это обязательный элемент. В нем указываются аргументы функции, с которыми идет работа. В нашем случае таковых нету, но элемент обязателен. Дальше идёт сам спавн объекта:

alife():create("wpn_ak74", db.actor:position(), db.actor:level_vertex_id(), db.actor:game_vertex_id(), db.actor:id())

В конце функции обязательно наличие end. Он означает конец функции. Логично, правда? :)

Напоминаю, при таком раскладе АК-74 заспавнится в рюкзак ГГ. Если же мы пожелаем заспавнить калаш где-нибудь на локации, вызов спавна приобретет следующий вид:

alife():create("wpn_ak74", vector():set(-81.800, -4.980, -72.739), 186578, 76)

АК заспавнится в вагончике, недалеко от Деревни новичков.

Но без детального разбора мы дальше, пожалуй,не пойдем. В целом, скелет функции спавна таким методом выглядит так:

function название_функции()
    alife():create("имя_секции_предмета", vector():set(x,y,z), level_vertex_id, game_vertex_id)
end

Про конкретные значения. alife():create - стандартный вызов спавна vector():set - инициализация координат x,y,z - координаты места по долготе, высоте, ширине level_vertex_id и game_vertex_id - дополнительные координаты относительно локации Все это нужно снимать в игре. Есть множество способов. Что касается спавна в рюкзак ГГ, тут с координатами действует немного другая схема. Объект актора можно получить посредством вот такой записи: db.actor, а получить его данные можно вот так:

db.actor:position() - координаты x,y,z актера

db.actor:level_vertex_id(),db.actor:game_vertex_id() - думаю, понятно

db.actor:id() - дополнительный параметр, сам id актера, нужен, чтоб предмет заспавнился именно в рюкзак.
На самом деле, для спавна в инвентарь атору, значение координат, левел и гейм вертексов не важны, а ключевым является последний параметр - id актора, в игре оно всегда равно нулю. Т.е. заспавнить тот же "Калаш" в рюкзак можно и так:

alife():create("wpn_ak74", vector(), 0, 0, 0)


Написали? Отлично!
Теперь осталось только подключить это к игре, то есть вызвать функцию спавна.
Идём в файл dialogs_escape.xml и выбираем какой-нибудь диалог.
Там, после поля text, одной из фраз диалога приписываем:

<action>my_test.ak_create</action>

Как это понимать:

<action>название_скрипта.название_функции</action>


Всё, сохраняем и тестируем. В итоге, когда вы в игре нажмёте на фразу после которой находится action, заспауниться калаш на указанных координатах.


Lamp.gif 	Углублённое изучение - Rez@niy
Далее идём в более углублённое изучение. Изучаем построение

Прописываем функцию. Задаём условие:

if логическое_условие then

Для закрытия тэга:

end

Ну и я напишу.Меченый(Стрелок)

Мой монолог построен так: В - Вопрос,О - Ответ

Начнём: В - Что такое ЦИКЛ? И как он выглядит? О - Цикл это повторение одного и того же действия n-ое кол-во раз выглядит так

for i=1,n,step do

end

За место i может быть любая переменная, за место n - число которое больше первоначального значения(i)
Здесь i - это счетчик цикла. Эта переменная локальна для цикла, т.е. она доступна только внутри тела цикла.
1 - начальное значение счетчика, n - конечное.
step - шаг цикла ( указывать необязательно, по умолчанию равно 1 )
Переменные, объявленные локальными в теле цикла, доступны только внутри цикла.

local con = get_console()
For i = 10,5,-2 do
	con:execute("i="..tostring(i)) -- выведет в консоль последовательно 10, 8, 6
end
con:execute("i="..tostring(i)) -- выведет строку "i=nil",т.к. счетчик уже недоступен.
 

В - А для чего можно использовать цикл? О - Чтобы выполнить некоторый набор инструкций несколько раз.
Пример 1.Перебор по id. Узнаем монстр ли объект,если да, то функция пишет в консоль строку вида "monster_"<имя объекта>, иначе "no_monster_"<имя объекта>

local con = console()
for id=1,65534 do
	local obj = level.object_by_id(id)
	if obj~= nil then
		if IsMonster(obj) then
			con:execute("monster_"..obj:name())
		else
			con:execute("no_monster_"..obj:name())
		end
	end
end

Пример 2.Спавн/

local pos = vector():set(-220.21,-19.93,-158.98)
for i=1,5 do --функция повторится 5 раз,следовательно будет заспавнено 5 АК 
	alife():create("wpn_ak47",pos,33447,47,65535)
end

и т.п. существует ещё цикл с предусловием (while a,n do),но об этом позже В - Какие параметры ГГ можно корректировать скриптами? О - Таких не много, запись будет такой :

db.actor.параметр

Параметры:

radiation
health
psy_health
power

В - а можно ли спавнить в рандомной точке предмет,если да,то как? О - можно Для этого нам понадобится таблица максимальных значений level_vertex_id и game_vertex_id выглядит она так:

local level_vertexes={
l01_escape = {lvid=595580, gvid=44},
l02_garbage = {lvid=384039, gvid=265},
l03_agroprom = {lvid=438379, gvid=693},
l04_darkvalley = {lvid=392517, gvid=813},
l06_rostok = {lvid=69283, gvid=1311},
l07_military = {lvid=915663, gvid=1546},
l10_radar = {lvid=796328, gvid=1868},
l11_pripyat = {lvid=295965, gvid=2269}
}

ЗЫ:Извините ,что не для всех уровней,исправлюсь Так, таблица у нас есть, теперь нам нужно написать функцию спавна. Давайте покажу на Монстрах. Создадим таблицу с секциями спавна монстров: (Я буду использовать свои наработки, поэтому таких секции у вас не будет, эта таблица - пример)

local mutants = {
"zombie_ghost_hell",
"zombie_normal_hell",
"zombie_immortal_hell",
"bloodsucker_weak_hell",
"tushkano_normal_hell",
"snork_weak_hell",
"burer_weak_hell",
"cat_weak_hell",
"chimera_weak_hell",
"gigant_strong_hell"
}

Таблицу записали ,наконец приступим к оформлению главной функции

function random_spawn()
local count = math.random(5,20) --выбираем кол-во заспавненых мобов
local section = mutants[math.random(table.getn(mutants))] -- выбираем секцию моба
local lv = math.random(level_vertexes[level.name()]["lvid"]) --выбираем левел вертекс
local gv = level_vertexes[level.name()]["gvid"] --выбираем гэйм вертекс
for ind = 1, count do
	alife():create(section, level.vertex_position(lv), lv, gv)--\\level.vertex_position(lv) - позиция левел вертекса
end
end

Далее помещаем вызов функции в bind_stalker.script в net_spawn() и при каждой загрузке будут спавнится мобы в рандомной точке

Вступление ГГ в группировку! 1.Создаем файл ваше_название_скприпта.script в папке gamedata/scripts 2. Открываем его и пишем: --меняем группировку ГГ

function new_group(actor, npc)
if npc:character_community() ~= "(dolg)" then 
	npc:set_character_community("dolg", 0, 0) 
end
end

Выдаём функцию при разговоре с НПС

НПС вступает в группировку

function ваше_название_функции(npc, actor)

Вызываем также, из любого диалога


Нельзя взять оружие без брони Пишем функцию в любом скрипе:

function ваше_название_функции()
	local armor = db.actor:item_in_slot(6) -- слот брони
	local weapon = db.actor:item_in_slot(2) -- слот оружия (для пистолетов в оригинале слот 1)
	if db.actor:active_slot()==2 and weapon then -- за место 2 пишем слот оружия еще раз
		local tmp = armor and armor:section() or ""
		if not string.find(tmp, "пишем_название_брони") and (weapon:section()=="пишем_название_оружия") then
			-- пример:if (not string.find(tmp, "exo" )) and weapon:section()=="wpn_pkm" then
 
			-- скидываем оружие из слота в инвентарь
			-- выкидываем оружие, и тем самым освобождаем слот
			db.actor:drop_item(weapon)
			-- спавним ствол с той же секцией, чтобы он занял слот
			local tmpw = amk.spawn_item_in_inv(weapon:section())
			-- подбираем выкинутый предмет обратно в инвентарь
			-- т.к. слот как бы занят он ляжет в рюкзак
			db.actor:transfer_item(weapon,db.actor)
			-- удаляем оружие в слоте
			alife():release(tmpw)
 
			-- выводим сообщение на экран о том, что нельзя брать оружие без определённой брони
			news_manager.send_tip(db.actor,"Невозможно взять пулемёт в руки без экзы",nil,nil,10000)
		end
	end
end

Далее идем по пути gamedata/script/bind_stalker.script Функция:

function actor_binder:update(delta)

Сразу ниже неё пиши вызов в формате :

название_файла.название_функции

Можешь написать эту функцию в любом файле из папки scripts, а можешь создать свой файл и назвать, скажем, my_script, и написать там. Должно быть так : Код

function actor_binder:update(delta)
my_script.check_armor()


Удаление предмета с заданным именем из игры

function name_function()
local se_obj = alife():object("сюда_пишем_что_удалять_будем")
if se_obj then
	alife():release(se_obj, true)
end
end

ПРИМЕР --' убираем финального Клыка

function dell_kluk_final()
local se_obj = alife():object("final_kluk")
if se_obj then
	alife():release(se_obj, true)
end
end


Я добавлю может кому и пригодится.Болотный Доктор

        ВЫДАЁМ ПРЕДМЕТ АКТОРУ

function название функции (first_speaker, second_speaker)
	dialogs.relocate_item_section(second_speaker, "название предмета", "in") 
end

Размещается в файлах скрипт.

Выдача поршня вставляется под строку действия.

<action>название скрипта.название функции</action>

Примечание, что бы выдать два одинаковых предмета пишем

function название функции (first_speaker, second_speaker)
	dialogs.relocate_item_section(second_speaker, "название предмета", "in",2) 
end

Если надо больше меняем цифру 2 на нужную нам.

     ОТБИРАЕМ ПРЕДМЕТ У АКТОРА.

function название функции(first_speaker, second_speaker)
    dialogs.relocate_item_section_from_actor(first_speaker, second_speaker, "название предмета")
end

размещается в файлах скрипт

выдача поршня вставляется под строку действия:

<action>название скрипта.название функции</action>

Примечание, что бы отобрать два одинаковых предмета пишем

function название функции(first_speaker, second_speaker)
    dialogs.relocate_item_section_from_actor(first_speaker, second_speaker, "название предмета",2)
end

Если надо больше меняем цифру 2 на нужную нам.

     СПАВНИМ ВЕЩЬ В РЮКЗАК ГГ

function название функции()
local obj = alife():create("ВЕЩЬ", db.actor:position(), db.actor:level_vertex_id(), db.actor:game_vertex_id(), db.actor:id())
end

В диалог:

<action>название скрипта.название функции</action>


ПРОВЕРКА НАЛИЧИЯ У АКТОРА ПРЕДМЕТА Вариант первый

function Название функции()
    if db.actor:object("название предмета") then
        return true
    end
    return false
end

в диалог:

<precondition>имя скрипта.название функции</precondition>

<---------Вариант второй)------------------>

function название функции(first_speaker, second_speaker)
    return first_speaker:object("название предмета") ~= nil
end

в диалог:

<precondition>имя скрипта.название функции</precondition>

ПРОВЕРКА ВЕЩЕЙ У ГГ

function Название функции(first_speaker, second_speaker)
    return first_speaker:object("название предмета") ~= nil or
             first_speaker:object("название предмета") ~= nil or
             first_speaker:object("название предмета") ~= nil
end

в диалог:

<precondition>имя скрипта.название функции</precondition>

описание... если есть хотя бы одна вещь, то мы получим фразу, если нет всех нет разговора

ПРОВЕРКА ДЕНЕГ У ГГ Вариант первый(используют ПЫС)

function название функции(first_speaker, second_speaker)
    return first_speaker:money() >= 2000
end

в диалог:

<precondition>имя скрипта.название функции</precondition>

<-----------Вариант два--------------> Использовал на ТЧ, но и в ЗП работает

function название функции()
return db.actor:money()>=10000
end

В диалог:

<precondition>имя скрипта.название функции</precondition>

СПАВН ПРЕДМЕТА

function spawn_vintar()
alife():create("Название предмета",vector():set(24.725412368774,-3.6072344779968,173.83030700684),993926,210)
end

В диалог:

<action>название скрипта.название функции</action>


МГНОВЕННАЯ СМЕРТЬ ГГ

function название функции(npc, actor)
    npc:kill(actor)
end

В диалог:

<action>название скрипта.название функции</action>

ПРОВЕРКА КОЛ_ВА ОДИНАКОВЫХ ПРЕДМЕТОВ

function название функции(first_speaker, second_speaker)
	local item_sections = {
		["medkit"] = 5, -- к примеру 5 аптечек
		["bandage"] = 2} -- и два бинта
 
	local function calc(temp, item)
		local sect = item:section()
		if item_sections[sect] and item_sections[sect]>0 then
			if item_sections[sect]==1 then
				item_sections[sect] = nil
			else
				item_sections[sect] = item_sections[sect] - 1
			end
		end
	end
 
	db.actor:iterate_inventory(calc, db.actor)
	return next(item_sections)==nil
end 
 

В диалог:

<precondition>имя скрипта.название функции</precondition>

ЛЕЧЕНИЕ ГГ Вставим этот экшен в диалог:

<action>dialogs.medic_magic_potion</action>

ВЫДАЧА ДЕНЕГ от НПС ГГ

function название функции(first_speaker, second_speaker)
    dialogs.relocate_money_to_actor(first_speaker, second_speaker, 2000)
end

В диалог:

<action>название скрипта.название функции</action>


ВЫДАЧА ДЕНЕГ от ГГ НПС

function название функции(actor, npc)
   dialogs.relocate_money(npc,кол-во,"out")   
end

В диалог:

<action>название скрипта.название функции</action>


НПС становится врагом после определенной ветки диалога или другом -5000 враг 5000 друг


function название скрипта(actor, npc)                                            
    npc:force_set_goodwill(-5000, actor)
end


<action>название скрипта.название функции</action>


ПРОВЕРКА СМЕРТИ NPC

function название функции проверки(actor,npc)
   return has_alife_info("инфо смерти")
end


В диалог:

<precondition>имя скрипта.название функции</precondition>